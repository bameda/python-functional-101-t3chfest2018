<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Functional Programming in Python 101</title>
    <meta name="description" content="Slides de la presentación de iniciación a la programación funcional en python para el T3chFest 2018.">
    <meta name="author" content="David Barragán Merino">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
  <body>

		<div class="reveal">
      <div class="slides">
        <!-- Cover -->
        <section>
          <h1>Functional Programming<br />in Python</h1>
          <p>
            <a href="http://kaleidos.net/FFF8E7/">David Barragán Merino</a>
            /
            <a href="http://twitter.com/bameda">@bameda</a>
          </p>
          <br /><br /><br /><br /><br /><br />
          <div style="display: flex; align-items: center; flex-direction: row; position:absolute; bottom: 0; right: 3em;">
            <img src="img/cover/t3chfest.svg"
                 style="border: 0; background: none; height: 2rem; margin-right: 1.5rem">
            <img src="img/cover/t3chfy.svg"
                 style="border: 0; background: none; height: 6rem;">
          </div>
        </section>

        <!-- Presentation -->
        <section style="text-align: left; padding-left: 15rem;" data-background="img/presentation/david-bg.png">
					<h3>Hi!</h3>
					<br />
					<h2>David Barragán Merino</h2>
					<p>
						<a href="http://kaleidos.net/FFF8E7/" style="color: #fff8e7">#FFF8E7</a>&nbsp;at&nbsp;
						<img src="img/presentation/kaleidos.svg"
								 style="border: 0; background: none; height: 4rem; vertical-align: middle;">&nbsp;Kaleidos.net
						<br>
						<a href="https://tree.taiga.io/humans.txt">Grouchy Smurf</a>&nbsp;at&nbsp;
						<img src="img/presentation/taiga.svg"
								 style="border: 0; background: none; height: 4.5rem; vertical-align: middle;">&nbsp;Taiga.io
					</p>
					<br />
					<p>
						<a href="https://github.com/bameda">bameda</a> on GitHub
						<br />
						<a href="https://twitter.com/bameda">@bameda</a> on Twitter
					</p>
        </section>

        <!-- Disclaimer -->
        <section data-background="#121661">
          <ul style="text-align: left; list-style-type: none;">
            <li>
							<h3 class="fragment">
								<img src="img/disclaimer/expert.svg"
                	   style="border: 0; background: none; height: 6rem; vertical-align: middle; box-shadow: none;" />
								I am not an expert
							</h3>
						</li>
            <li>
							<h3 class="fragment">
								<img src="img/disclaimer/opinion.svg"
                     style="border: 0; background: none; height: 6rem; vertical-align: middle; box-shadow: none;" />
								But I have an opinion
							</h3>
						</li>
            <li>
							<h3 class="fragment">
								<img src="img/disclaimer/baby.svg"
                     style="border: 0; background: none; height: 6rem; vertical-align: middle; box-shadow: none;" />
								It's a 101 talk
							</h3>
						</li>
            <li>
							<h3 class="fragment">
								<img src="img/disclaimer/python.svg"
                     style="border: 0; background: none; height: 6rem; vertical-align: middle; box-shadow: none;" />
								I use Python 3 ALWAYS (<a href="https://pythonclock.org/">Python 2.7 countdown</a>)
              </h3>
						</li>
          </ul>
        </section>

        <!-- -->
        <section>
          <h2>¿Qué es la programación funcional?</h2>
        </section>

        <!-- -->
        <section>
          <h2></h2>
        </section>

        <!-- Imperative vs Fuctional-->
        <section>
          <section>
            <h2>Imperative vs Declarative</h2>
            <h3>(HOW vs WHAT?)</h3>
						<p>Calculate partially invalid string with operation.</p>
            <pre><code class="python" data-trim>
              input = "23+45++++2++5++32++100"
            </code></pre>
          </section>
          <section>
            <p>Actions that change state from initial state to resultI =&gt; Imperative style =&gt; HOW?</p>
            <pre class="fragment"><code class="python" data-trim>
              input = "23+45++++2++5++32++100"

              res = 0
              for t in input.split("+"):
                  if t:
                    res += int(t)

              print(res)
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              ["23", "45", "", "", "", "2", "", "5", "", "32", "", "100"], 0
              "23", 0
              "45", 23
              "2", 68
              "5", 70
              "32", 75
              "100", 107
              207
            </code></pre>
          </section>
          <section>
            <p>Apply rules, restrictions, transformation (and compositions) =&gt; Declarative style =&gt; WHAT</p>
            <pre class="fragment"><code class="python" data-trim>
              input = "23+45++++2++5++32++100"

              from functools import reduce
              from operator import add

              res = reduce(add, map(int, filter(bool, input.split("+"))))

              print(res)
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              ["23", "45", "", "", "", "2", "", "5", "", "32", "", "100"]
              ["23", "45", "2", "5", "32", "100"]
              [23, 45, 2, 5, 32, 100]
              207
            </code></pre>
          </section>
        </section>

        <!-- List comprenhension -->
        <section>
          <section>
            <h2>List comprenhension</h2>
            <div class="fragment"
                 style="display: flex; flex-direction: row; justify-content: center; align-content: center; align-items: center">
              <div style="width: 32rem; padding-right: 2rem">
                Calculate the combinations of the rock-paper-scissors game for which there is a winner.
              </div>
              <img src="img/list-comp/rock-paper-scissors.svg"
                   style="border: 0; background: none; height: 32rem; vertical-align: middle; box-shadow: none; padding-left: 2rem" />
            </div>
          </section>
          <section>
            <pre><code class="python" data-trim>
              values = ['rock', 'paper', 'scissors']
              combs = []
              for x in values:
                  for y in values:
                      if x != y:
                          combs.append((x, y))
              print(combs)
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              [('rock', 'paper'), ('rock', 'scissors'), ('paper', 'rock'),
               ('paper', 'scissors'), ('scissors', 'rock'), ('scissors', 'paper')]
            </code></pre>
          </section>
          <section>
            <pre><code class="python" data-trim>
              values = ['rock', 'paper', 'scissors']
              combs = [(x, y) for x in values for y in values if x != y]
              print(combs)
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              [('rock', 'paper'), ('rock', 'scissors'), ('paper', 'rock'),
               ('paper', 'scissors'), ('scissors', 'rock'), ('scissors', 'paper')]
            </code></pre>
            <p class="fragment">Are you sure you can not do it better?</p>
          </section>
        </section>

        <!-- Iterators & Generators -->
        <section>
        	<section>
						<h2>Iterators & Generators</h2>
						<blockquote style="text-align: left;">
              <strong>iterable:</strong> An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict, file objects, and objects of any classes you define with an <code>__iter__()</code> method or <code>__getitem__</code> (...) When an iterable object is passed as an argument to the built-in function <code>iter()</code>, it returns an iterator for the object. This iterator is good for one pass over the set of values.
						</blockquote>
						<blockquote class="fragment" style="text-align: left;">
            <strong>__iter__:</strong>This method is called when an iterator is required for a container. This method should return a new iterator object that can iterate over all the objects in the container. For mappings, it should iterate over the keys of the container.
            </blockquote>
        	</section>
        	<section>
						<blockquote style="text-align: left;">
              <strong>iterator:</strong> An object representing a stream of data. Repeated calls to the iterator’s <code>__next__()</code> method (or passing it to the built-in function <code>next()</code>) return successive items in the stream. When no more data are available a <code>StopIteration</code> exception is raised instead. At this point, the iterator object is exhausted and any further calls to its <code>__next__()</code> method just raise <code>StopIteration</code> again. Iterators are required to have an <code>__iter__()</code> method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted.
            </blockquote>
        	</section>
        	<section>
            <pre><code class="python" data-trim>
              l = [1, 2, 3, 4]
              l.__iter__
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              &lt;method-wrapper '__iter__' of list object at 0x7ff9ec499488&gt;
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              l.__next__
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              ---------------------------------------------------------------------------
              AttributeError                            Traceback (most recent call last)
              &lt;ipython-input-21-39daa3570050&gt; in &lt;module&gt;()
              ----&gt; 1 l.__next__

              AttributeError: 'list' object has no attribute '__next__'
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              li = iter(l)
              li.__next__
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              &lt;method-wrapper '__next__' of list_iterator object at 0x7ff9ec514240&gt;
            </code></pre>
        	</section>
        	<section>
            <pre><code class="python" data-trim>
              class yrange:
                  def __init__(self, n):
                      self.i = 0
                      self.n = n

                  def __iter__(self):
                      return self

                  def __next__(self):
                      if self.i &lt; self.n:
                          i = self.i
                          self.i += 1
                          return i
                      else:
                          raise StopIteration()
            </code></pre>
        	</section>
        	<section>
            <pre><code class="python" data-trim>
              y = yrange(3)
              print(next(y))
              print(next(y))
              print(next(y))
              print(next(y))
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              0
              1
              2
              ---------------------------------------------------------------------------
              StopIteration                             Traceback (most recent call last)
              &lt;ipython-input-49-c97cadfde7e4&gt; in &lt;module&gt;()
                    3 print(next(y))
                    4 print(next(y))
              ----&gt; 5 print(next(y))

              &lt;ipython-input-45-79e514da8e3b&gt; in __next__(self)
                   13             return i
                   14         else:
              ---&gt; 15             raise StopIteration()

              StopIteration:
            </code></pre>
        	</section>
        	<section>
            <pre><code class="python" data-trim>
              class zrange:
                  def __init__(self, n):
                      self.n = n

                  def __iter__(self):
                      return zrange_iter(self.n)
            </code></pre>
            <pre><code class="python" data-trim>
              class zrange_iter:
                  def __init__(self, n):
                      self.i = 0
                      self.n = n

                  def __iter__(self):
                      return self

                  def __next__(self):
                      if self.i &lt; self.n:
                          i = self.i
                          self.i += 1
                          return i
                      else:
                          raise StopIteration()
            </code></pre>
        	</section>
        	<section>
            <pre><code class="python" data-trim>
              y = yrange(5)
              print(list(y))
              print(list(y))
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              [0, 1, 2, 3, 4]
              []
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              z = zrange(5)
              print(list(z))
              print(list(z))
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              [0, 1, 2, 3, 4]
              [0, 1, 2, 3, 4]
            </code></pre>
        	</section>
        	<section>
						<blockquote style="text-align: left;">
  						<strong>generator</strong> A function which returns a generator iterator. It looks like a normal function except that it contains <code>yield</code> expressions for producing a series of values usable in a for-loop or that can be retrieved one at a time with the <code>next()</code> function.
						</blockquote>
						<blockquote style="text-align: left;">
	  					<strong>generator iterator</strong> An object created by a generator function.
						</blockquote>
          </section>
          <section>
            <pre><code class="python" data-trim>
              def my_generator():
                yield 1
                yield 2
                yield 3
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              g = my_generator()
              print(g)
              print(next(g))
              print(next(g))
              print(next(g))
              print(next(g))
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              &lt;generator object my_generator at 0x7ff9ec48fc50&gt;
              a
              b
              c
              ---------------------------------------------------------------------------
              StopIteration                             Traceback (most recent call last)
              &lt;ipython-input-55-567ce73dea18&gt; in &lt;module&gt;()
                    4 print(next(g))
                    5 print(next(g))
              ----&gt; 6 print(next(g))

              StopIteration:
            </code></pre>
          </section>
          <section>
            <pre><code class="python" data-trim>
              def get_even(stop):
                  """Return all the even numbers &lt;= stop."""

                  numbers = []
                  n = 0
                  while n &lt;= stop:
                      numbers.append(n)
                      n += 2
                  return numbers
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              print(get_even(10))

              [0, 2, 4, 6, 8, 10]
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              print(get_even(1e18))

              ===================================================================
              | Kernel restarting                                               |
              |                                                                 |
              | The kernel appears to have died. It will restart automatically. |
              ===================================================================
            </code></pre>
          </section>
          <section>
            <pre><code class="python" data-trim>
              def count():
                  n = 0
                  while True:
                      yield n
                      n +=1
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              counter = count()
              print(next(counter))
              print(next(counter))
              print(next(counter))
              print(next(counter))
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              0
              1
              2
              3
            </code></pre>
          </section>
          <section>
            <p>Let's go back to the previous example...</p>
            <pre><code class="python" data-trim>
              values = ['rock', 'paper', 'tijer ']
              combs = ((x, y) for x in values for y in values if x != y)
              print(combs)
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
							&lt;generator object &lt;genexpr&gt; at 0x7ff9ec545468&gt;
            </code></pre>
						<pre class="fragment"><code class="python" data-trim>
							next(combs)
							('rock', 'paper')

							next(combs)
							('rock', 'scissors')
						</code></pre>
          </section>
          <section>
            <h3>In summary:</h3>
            <ul style="text-align: left;">
              <li>An iterable is an object capable of returning its members one by one. Implement the <code>__ite __()</code> <span style="color: gray;">or <code>__getitem__()</code> method</span>.</li>
              <li>An iterator is an iterable object since it is returned to itself that also adds the method <code>__next__()</code>.</li>
              <li>Iterators are lazy (calculated when they are needed).</li>
              <li>Iterators are for a single use.</li>
              <li>A generator function is a function capable of returning values one by one (using <code>yield</code>), returning a generator.</li>
              <li>A generator is a kind of iterator generated by a generator function.</li>
              <li>A generator expression is like a list comprenhension but with the benefits of the generators.</li>
            </ul>
            <br /><br />
            <small class="fragment">
              If you need mutch more, read <a href="http://www.dabeaz.com/generators/">"Generator Tricks for Systems Programmers"</a> by David M. Beazley
              <br/ >and some Python Enhancement Proposals <a href="https://www.python.org/dev/peps/pep-0288/" title="PEP 288 -- Generators Attributes and Exceptions">PEP 288</a>
              , <a href="https://www.python.org/dev/peps/pep-0325/" title="PEP 325 -- Resource-Release Support for Generators">PEP 325</a>
              , <a href="https://www.python.org/dev/peps/pep-0342/" title="PEP 342 -- Coroutines via Enhanced Generators">PEP 342</a>
              and <a href="https://www.python.org/dev/peps/pep-0380/" title="PEP 380 -- Syntax for Delegating to a Subgenerator">PEP 380</a>.
            </small>
          </section>
        </section>

        <!-- Lambda Functions -->
        <section>
          <section>
            <h2>Lambda functions</h2>
            <blockquote style="text-align: left;">
              <strong>lambda:</strong>An anonymous inline function consisting of a <strong>single expression</strong> which is evaluated when the function is called. The syntax to create a lambda function is <code>lambda [arguments]: expression</code>
            </blockquote>
            <blockquote class="fragment" style="text-align: left;">
              <strong>expression</strong>
  A piece of syntax which can be evaluated to some value. In other words, an expression is an accumulation of expression elements like literals, names, attribute access, operators or function calls which all return a value.
            </blockquote>
            </br />
            <pre class="fragment"><code class="python" data-trim>
              sum_numbers = lambda x, y: x+y
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              print(sum_numbers)
              &lt;function &lt;lambda&gt; at 0x7f0aef3d9ea0&gt;
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              sum_numbers(1, 4)
              5
            </code></pre>
          </section>
          <section>
            <pre><code class="python" data-trim>
              even_or_odd = lambda x: "even" if x % 2 == 0 else "odd"

              print(f"1 is {even_or_odd(1)}")
              print(f"4 is {even_or_odd(4)}")
              print(f"22 is {even_or_odd(22)}")
              print(f"1479 is {even_or_odd(1479)}")
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              1 is odd
              4 is even
              22 is even
              1479 is odd
            </code></pre>
          </section>
        </section>

        <!-- itertools -->
        <section>
          <section>
            <h2>itertools</h2>
            <p>This module implements a number of iterator building blocks inspired by constructs from APL, Haskell, and SML. Each has been recast in a form suitable for Python.</p>
            <p>The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an “iterator algebra” making it possible to construct specialized tools succinctly and efficiently in pure Python.</p>
            <dl class="fragment">
              <dt>Infinite iterators:</dt> <dd><code>count()</code>, <code>cycle()</code>, <code>repeat()</code></dd>
              <dt>Iterators terminating on the shortest input sequence:</dt><dd><code>accumulate()</code>, <code>chain()</code>, <code>chain.from_iterable()</code>, <code>compress()</code>, <code>dropwhile()</code>, <code>filterfalse()</code>, <code>groupby()</code>, <code>islice()</code>, <code>starmap()</code>, <code>takewhile()</code>, <code>tee()</code>, <code>zip_longest()</code></dd>
              <dt>Combinatoric iterators:</dt><dd><code>product()</code>, <code>permutations()</code>, <code>combinations()</code>, <code>combinations_with_replacement()</code></dd>
            </dl>
            <p class="fragment">
              See <a href="https://docs.python.org/3.6/library/itertools.html">itertools doc</a>.
            </p>
          </section>
          <section>
            <h4>Ex.: A (rudimentary) compression algorithm</h4>
            <p>
              Let's implement a very basic string compression function using the counts of repeated characters.<br /> For example:
            </p>
            <pre><code class="python" data-trim>
              compress("sssdddddxxaaaaaa")
              "s3d5x2a6"
            </code></pre>
          </section>
          <section>
            <p>...without itertools</p>
            <pre><code class="python" data-trim>
              def compress(word):
                  result = []
                  current = word[0]
                  counter = 1

                  for letter in word[1:]:
                      if letter == current:
                          # We're still in the same group
                          counter += 1
                      else:
                          # We need to start a new group
                          result += [current, str(counter)]
                          current = letter # start a new group
                          counter = 1
                  result += [current, str(counter)]
                  return "".join(result)


              compress("sssdddddxxaaaaaa")
              "s3d5x2a6"
            </code></pre>
          </section>
          <section>
            <p>...with itertools</p>
            <dl class="fragment">
              <dt>
                <code>itertools.groupby(iterable, key=None)</code>
              </dt>
              <dd>
								Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is <code>None</code>, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function.
								<br /><br />
                The operation of groupby() is similar to the uniq filter in Unix. It generates a break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function). That behavior differs from SQL’s GROUP BY which aggregates common elements regardless of their input order.
              </dd>
            </dl>
						<br /><br />
            <pre class="fragment"><code class="python" data-trim>
              def compress(word):
                  return ''.join(f"{key}{len(list(group))}"
														     for key, group in itertools.groupby(word))


              compress("sssdddddxxaaaaaa")
              "s3d5x2a6"
           </code></pre>
          </section>
          <section>
            <h4>Ex.: Rolling dices</h4>
            <p>If we roll four six-sided dices, what are their posible outcomes?</p>
						<div class="fragment">
							<p>...without itertools</p>
							<pre><code class="python" data-trim>
                def product(first, second, third, fourth):
                    """A generator of the Cartesian product of four iterables."""
                    for w in first:
                        for x in second:
                            for y in third:
                                for z in fourth:
                                    yield (w, x, y, z)


                dice = range(1, 7)
                tuple(product(dice, dice, dice, dice))
							</code></pre>
						</div>
          </section>
          <section>
            <p>...with itertools</p>
            <dl class="fragment">
              <dt>
                <code>itertools.product(*iterables, repeat=1)</code>
              </dt>
              <dd>
                Cartesian product of input iterables.
								</br/ ><br />
                (...) To compute the product of an iterable with itself, specify the number of repetitions with the optional <code>repeat</code> keyword argument. For example, <code>product(A, repeat=4)</code> means the same as <code>product(A, A, A, A)</code>.
              </dd>
            </dl>
						<br /><br />
            <pre class="fragment"><code class="python" data-trim>
							import itertools
							dice = range(1, 7)
							tuple(itertools.product(dice, repeat=4))
            </code></pre>
						<p class="fragment">...and in how many outcomes they add up to 6?</p>
            <pre class="fragment"><code class="python" data-trim>
              tuple(
                  filter(lambda x: sum(x) == 6,
                         itertools.product(dice, repeat=4))
              )
            </code></pre>
          </section>
          <section>
						<p class="fragment">...but in the real life?</p>
            <pre class="fragment"><code class="python" data-trim>
              import collections, itertools

              class Coord(collections.namedtuple("Coord", "x y")):
                  def neighbours(self):
                      """Return a generator of the eight neighbours of a coordinate."""
                      cls = type(self)
                      for x_delta, y_delta in itertools.product([-1, 0, 1], repeat=2):
                          if x_delta or y_delta:
                              yield cls(self.x + x_delta, self.y + y_delta)


              tuple(Coord(12, 4).neighbours())
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              (Coord(x=11, y=3), Coord(x=11, y=4), Coord(x=11, y=5),
               Coord(x=12, y=3), Coord(x=12, y=5),
               Coord(x=13, y=3), Coord(x=13, y=4), Coord(x=13, y=5))
            </code></pre>
            <small class="fragment">
              To know more about irtertools see:
              </br />
              Víctor Terrón (@pyctor) - Kung Fu at Dawn with Itertools  (<a href="https://www.youtube.com/watch?v=iCrOGS1QlB8">Video EN</a> / <a href="https://www.youtube.com/watch?v=4ZIxcdREYVc">Video ES</a> / <a href="https://github.com/vterron/EuroPython-2016">Repo</a>) [CC BY-SA 2.0].
            </small>
          </section>
        </section>

        <!-- Higher-order functions: functools -->
        <section>
          <section>
            <h2>Higher-order functions</h2>
            <blockquote style="text-align: left;">
              In mathematics and computer science, a higher-order function <del>(also functional, functional form or functor)</del> is a function that takes one or more functions as arguments or return a function.
              <br />
              <div style="text-align: right">
                <small>
                  <a href="https://en.wikipedia.org/wiki/Higher-order_function#Python">Higher-order function</a>
                  <br />from Wikipedia
                </small>
              </div>
            </blockquote>
            <br />
            <pre class="fragment"><code class="python" data-trim>
              def twice(f):
                  return lambda x: f(f(x))

              plus_three = lambda x: x + 3

              twice_plus_three = twice(plus_three)
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              twice_plus_three(10)
              16
            </code></pre>
            <p class="fragment">
              Python comes with some higher-order functions
            </p>
          </section>
          <section>
            <dl>
              <dt>
                <code>map(function, iterable, ...)</code>
              </dt>
              <dd>
                Return an iterator that applies function to every item of iterable, yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, <code>see itertools.starmap()</code>.
              </dd>
            </dl>
						</br/ ><br />
            <pre class="fragment"><code class="python" data-trim>
              tuple(map(lambda x, y: (x,y), (1, 2, 3, 4), ('a', 'b', 'c', 'd')))

              ((1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'))
            </code></pre>
          </section>
          <section>
            <dl>
              <dt>
                <code>filter(function, iterable)</code>
              </dt>
              <dd>
                Construct an iterator from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed.
                <br /><br />
                Note that <code>filter(function, iterable)</code> is equivalent to the generator expression <code>(item for item in iterable if function(item))</code> if function is not <code>None</code> and <code>(item for item in iterable if item)</code> if function is <code>None</code>.
                <br /><br />
                See <code>itertools.filterfalse()</code> for the complementary function that returns elements of iterable for which function returns false.
              </dd>
            </dl>
						</br/ ><br />
            <pre class="fragment"><code class="python" data-trim>
              tuple(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 15, 17, 32, 1986]))

              (2, 4, 32, 1986)
            </code></pre>
          </section>
          <section>
            <dl>
              <dt>
                <code>sorted(iterable, *, key=None, reverse=False)</code>
              </dt>
              <dd>
                Return a new sorted list from the items in iterable.
                <br /><br />
                Has two optional arguments which must be specified as keyword arguments.
                <br /><br />
                <code>key</code> specifies a function of one argument that is used to extract a comparison key from each list element: <code>key=str.lower</code>. The default value is None (compare the elements directly).
                <br /><br />
                <code>reverse</code> is a boolean value. If set to <code>True</code>, then the list elements are sorted as if each comparison were reversed.
                <br /><br />
                The built-in <code>sorted()</code> function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade).
              </dd>
            </dl>
          </section>
          <section>
            <pre><code class="python" data-trim>
              from collections import namedtuple

              Student = namedtuple('Student', ('name', 'age', 'grade'))

              students = (
                  Student("María", 21, 'C'),
                  Student("Pedro", 22, 'B'),
                  Student("Rosa", age=21, grade='A')
              )

              sorted(students, key=lambda s: s.age)
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              [Student(name='María', age=21, grade='C'),
               Student(name='Rosa', age=21, grade='A'),
               Student(name='Pedro', age=22, grade='B')]
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              from operator import attrgetter
              sorted(students, key=attrgetter('age', 'grade'))
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              [Student(name='Rosa', age=21, grade='A'),
               Student(name='María', age=21, grade='C'),
               Student(name='Pedro', age=22, grade='B')]
            </code></pre>
          </section>
        </section>

        <!-- functools, clousers and decorators -->
        <section>
          <section>
            <h2>functools</h2>
						<p>The functools module is for higher-order functions: functions that act on or return other functions. In general, any callable object can be treated as a function for the purposes of this module.</p>
            <p class="fragment">
              See <a href="https://docs.python.org/3.6/library/functools.html">functools doc</a>.
            </p>
          </section>
          <section>
            <dl>
              <dt>
                <code>functools.reduce(function, iterable[, initializer])</code>
              </dt>
              <dd>
								Apply function of two arguments cumulatively to the items of sequence, from left to right, so as to reduce the sequence to a single value. For example, <code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> calculates <code>((((1+2)+3)+4)+5)</code>. The left argument, x, is the accumulated value and the right argument, y, is the update value from the sequence. If the optional initializer is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. If initializer is not given and sequence contains only one item, the first item is returned.
              </dd>
            </dl>
            <pre class="fragment"><code class="python" data-trim>
						  import functools
              functools.reduce(lambda x, y: x * y, range(1, 11))
            </code></pre>
          </section>
          <section>
            <dl>
              <dt>
                <code>@functools.lru_cache(maxsize=128, typed=False)</code>
              </dt>
              <dd>
                Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls. It can save time when an expensive or I/O bound function is periodically called with the same arguments. (...) If <code>maxsize</code> is set to <code>None</code>, the LRU feature is disabled and the cache can grow without bound. The LRU feature performs best when maxsize is a power-of-two. If <code>typed</code> is set to <code>true</code>, function arguments of different types will be cached separately.
              </dd>
            </dl>
            <pre class="fragment"><code class="python" data-trim>
              import functools

              @functools.lru_cache()
              def get_heavy_query(param):
                  print(f"Accessing to the db (param={param}")
                  return param * 3

              print(get_heavy_query(1))
              print(get_heavy_query(2))
              print(get_heavy_query(1))
              print(get_heavy_query(2))
              print(get_heavy_query(3))
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              Accessing to the db (param=1
              3
              Accessing to the db (param=2
              6
              3
              6
              Accessing to the db (param=3
              9
            </code></pre>

          </section>
          <section>
            <h3>Clousures and decorators</h3>
            <br />
            <pre class="fragment"><code class="python" data-trim>
              class Multiplier:
                  def __init__(self, n):
                      self.n = n

                  def multiplier(self, x):
                      return self.n * x
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              times3 = Multiplier(3)
              times5 = Multiplier(5)

              print(times3.multiplier(9))
              27
              print(times5.multiplier(3))
              15
              print(times5.multiplier(times3.multiplier(2)))
              30
            </code></pre>
          </section>
          <section>
            <pre class="fragment"><code class="python" data-trim>
              def make_multiplier_of(n):
                  def multiplier(x):
                      return x * n
                  return multiplier
            </code></pre>
          </section>
          <section>
            <pre><code class="python" data-trim>
              times3 = make_multiplier_of(3)
              times5 = make_multiplier_of(5)

              print(times3(9))
              27
              print(times5(3))
              15
              print(times5(times3(2)))
              30
            </code></pre>
            <pre class="fragment"><code class="python" data-trim>
              print(make_multiplier_of.__closure__)
              None
              print(times3.__closure__[0].cell_contents)
              3
            </code></pre>
          </section>
        </section>

        <!-- Aplicación parcial -->
        <section>
          <h2></h2>
        </section>

        <!-- Currificación -->
        <section>
          <h2></h2>
        </section>

        <!-- -->
        <section>
          <h2></h2>
        </section>

        <!-- -->
        <section>
          <h2>Bibliografía</h2>
          <ul style="font-size: .7em;">
            <li><a href="https://docs.python.org/3/glossary.html">[Doc]</a>Python Glossary</li>
            <li><a href="https://docs.python.org/dev/howto/functional.html">[Doc}</a>Functional Programming HOWTO</li>

            <li><a href="https://www.youtube.com/watch?v=4ZIxcdREYVc">[Video Talk}</a>Kung Fu at Dawn with Itertools (Victor Terrón) [Vídeo]</li>
            <li><a href="https://github.com/vterron/EuroPython-2016">[Doc Talk}</a>Kung Fu at Dawn with Itertools (Victor Terrón) [Repo]</li>
            <li><a href="http://www.dabeaz.com/generators/">[Doc Talk}</a>Generator Tricks for Systems Programmers (David M. Beazley)</li>
            <li><a href="https://www.python.org/3.6/peps/pep-0288/">[Doc}</a>PEP 288 -- Generators Attributes and Exceptions</li>
            <li><a href="https://www.python.org/3.6/peps/pep-0325/">[Doc}</a>PEP 325 -- (Resource-Release Support for Generators</li>
            <li><a href="https://www.python.org/3.6/peps/pep-0342/">[Doc}</a>PEP 342 -- Coroutines via Enhanced Generators</li>
            <li><a href="https://www.python.org/3.6/peps/pep-0380/">[Doc}</a>PEP 380 -- Syntax for Delegating to a Subgenerator</li>
            <li><a href="https://docs.python.org/3.6/library/itertools.html">[Doc]</a>itertools — Functions creating iterators for efficient looping</li>

            <li><a href="https://docs.python.org/3.6/howto/sorting.html#sortinghowto">[Doc]</a>Sorting HOW TO</li>
            <li><a href="https://docs.python.org/3.6/library/functools.html">[Doc]</a>functools — Higher-order functions and operations on callable objects</li>

            <li><a href="https://docs.python.org/3.6/library/collections.html#module-collections">[Doc]</a>collections — Container datatypes</li>
            <li><a href="https://docs.python.org/3.6/library/operator.html?highlight=operator">[Doc]</a>operator — Standard operators as functions</li>

            <li><a href="">[]</a></li>
            <li><a href="">[]</a></li>
            <li><a href="">[]</a></li>
            <li><a href="">[]</a></li>
          </ul>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        // Settings
       	width: "1920",
	      height: "1080",
       	//width: "100%",
	      //height: "100%",
	      //margin: 0,
	      //minScale: 1,
        //maxScale: 1,
        // Plugin: elapsed-time-bar
        allottedTime: 40 * 60 * 1000, // 40 minutes
        progressBarHeight: 5,
        barColor: '#005db2',
        pausedBarColor: '#fff8e7',
        // Keyboard bindings
        keyboard: {
          // pause/resume time when Enter is pressed
          13: () => {
            ElapsedTimeBar.isPaused ? ElapsedTimeBar.resume() : ElapsedTimeBar.pause();
          },
          // reset timer when 'r' is pressed
          82: () => {
            ElapsedTimeBar.reset();
          }
        },
        // Dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/elapsed-time-bar/elapsed-time-bar.js'}
				]
			});
		</script>
	</body>
</html>
